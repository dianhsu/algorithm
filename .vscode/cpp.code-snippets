{
	// Place your algorithm 工作区 snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
    "Mod Int" : {
        "scope": "cpp",
        "prefix": "mint",
        "description": "Mod Int Number",
        "body": [
            "template <typename P = int, typename Q = long long, P MOD = 998244353>",
            "class MInt {",
            "public:",
            "  static P selfPow(P base, P p) {",
            "    Q ret = 1;",
            "    while (p) {",
            "      if (p & 1)",
            "        ret = (ret * base) % MOD;",
            "      p >>= 1;",
            "      base = ((Q)base * base) % MOD;",
            "    }",
            "    return ret;",
            "  }",
            "  MInt() : val(0) {}",
            "  MInt(P tv) : val(tv) {}",
            "  MInt operator+(const MInt &arg) const {",
            "    return MInt((val + (Q)arg.val) % MOD);",
            "  }",
            "  MInt operator-(const MInt &arg) const {",
            "    return MInt(((Q)val + MOD - (Q)arg.val) % MOD);",
            "  }",
            "  MInt operator*(const MInt &arg) const {",
            "    return MInt((val * (Q)arg.val) % MOD);",
            "  }",
            "  MInt operator/(const MInt &arg) const {",
            "    return MInt((val * (Q)selfPow(arg.val, MOD - 2)) % MOD);",
            "  }",
            "  MInt operator+(const P argv) const { return MInt((val * (Q)argv) % MOD); }",
            "  MInt operator-(const int argv) const {",
            "    return MInt(((Q)val + MOD - (Q)argv) % MOD);",
            "  }",
            "  MInt operator*(const int argv) const { return MInt((val * (Q)argv) % MOD); }",
            "  MInt operator/(const int argv) const {",
            "    return MInt((val * (Q)selfPow(argv, MOD - 2)) % MOD);",
            "  }",
            "  MInt &operator+=(const MInt &arg) {",
            "    this->val = ((Q)this->val + (Q)arg.val) % MOD;",
            "    return *this;",
            "  }",
            "  MInt &operator-=(const MInt &arg) {",
            "    this->val = ((Q)this->val + MOD - (Q)arg.val) % MOD;",
            "    return *this;",
            "  }",
            "  MInt &operator*=(const MInt &arg) {",
            "    this->val = ((Q)this->val * arg.val) % MOD;",
            "    return *this;",
            "  }",
            "  MInt &operator/=(const MInt &arg) {",
            "    this->val = ((Q)this->val * (Q)selfPow(arg.val, MOD - 2)) % MOD;",
            "    return *this;",
            "  }",
            "  MInt &operator+=(const int argv) {",
            "    this->val = ((Q)this->val + (Q)argv) % MOD;",
            "    return *this;",
            "  }",
            "  MInt &operator-=(const int argv) {",
            "    this->val = ((Q)this->val + MOD - (Q)argv) % MOD;",
            "    return *this;",
            "  }",
            "  MInt &operator*=(const int argv) {",
            "    this->val = ((Q)this->val * (Q)argv) % MOD;",
            "    return *this;",
            "  }",
            "  MInt &operator/=(const int argv) {",
            "    this->val = ((Q)this->val * (Q)selfPow(argv, MOD - 2)) % MOD;",
            "    return *this;",
            "  }",
            "  MInt &operator=(const MInt &arg) {",
            "    this->val = (Q)arg.val % MOD;",
            "    return *this;",
            "  }",
            "  MInt &operator=(const int argv) {",
            "    this->val = (Q)argv % MOD;",
            "    return *this;",
            "  }",
            "  bool operator==(const int argv) const { return (Q)val == (Q)argv; }",
            "",
            "  friend MInt operator+(const int argv, const MInt &arg) {",
            "    return MInt(((Q)arg.val + (Q)argv) % MOD);",
            "  }",
            "  friend MInt operator-(const int argv, const MInt &arg) {",
            "    return MInt(((Q)argv + MOD - (Q)arg.val) % MOD);",
            "  }",
            "  friend MInt operator*(const int argv, const MInt &arg) {",
            "    return MInt(((Q)arg.val * (Q)argv) % MOD);",
            "  }",
            "  friend MInt operator/(const int argv, const MInt &arg) {",
            "    return MInt(((Q)argv * (Q)MInt::selfPow(arg.val, MOD - 2)) % MOD);",
            "  }",
            "  friend istream &operator>>(istream &its, MInt &arg) {",
            "    its >> arg.val;",
            "    return its;",
            "  }",
            "  friend ostream &operator<<(ostream &ots, const MInt &arg) {",
            "    ots << arg.val;",
            "    return ots;",
            "  }",
            "  friend P abs(const MInt &arg) { return abs(arg.val); }",
            "",
            "private:",
            "  P val;",
            "};"
        ]
    },
	"Disjoint Union": {
		"scope": "cpp",
		"prefix": "dsu",
		"body": [
			"class DSU {",
			"public:",
			"  vector<int> fa;",
			"  vector<int> sz;",
			"  DSU(int n): fa(n), sz(n, 1) {",
			"    iota(fa.begin(), fa.end(), 0);",
			"  }",
			"  int tf(int x) {",
			"    if (fa[x] == x) {",
			"       return x;",
			"    }",
			"    return fa[x] = tf(fa[x]);",
			"  }",
			"  void mg(int x, int y) {",
			"    int a = tf(x);",
			"    int b = tf(y);",
			"    if (a == b) {",
			"      return;",
			"    }",
			"    if (sz[a] < sz[b]) {",
			"      swap(a, b);",
			"    }",
			"    fa[b] = a;",
			"    sz[a] += sz[b];",
			"  }",
			"};"
		]
	}
}